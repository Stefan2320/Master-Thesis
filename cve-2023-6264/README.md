# CVE-2023-6264  analysis

## Context

This CVE exploits a heap-overflow in the `\_\_vsyslog\_internal` function of glibc. This function is called by  `syslog` and `vsyslog`. This CVE has a cvss3 severity of 7.8 .

It was introduced in glibc 2.37 with the following commit: https://sourceware.org/git?p=glibc.git;a=commit;h=52a5be0df411ef3ff45c10c7c308cb92993d15b1
It also affects glibc 2.36 since the commit was backported to solve CVE-2022-39046 (https://sourceware.org/bugzilla/show\_bug.cgi?id=29536).

With this vulnerability an attacker can gain LPE (Local Privilege Escalation). 

# Target functions

Before looking at the vulnerable code, let's see what the affected functions are meant to do.

`syslog` man page - `send messages to the system logger. Generates a log message, which will be distributed by syslogd(8).`
Where `syslogd` is a daemon that would read messages from `/dev/log` (from processes and applications) and would direct the to `/var/log/`. Altough there is a replacement now for this `journald` where the logs are written in binary and need to use `journalctl` to view them as text.

A syslog message has a format described in [RFC5424](https://www.rfc-editor.org/rfc/rfc5424.html#section-6).

The `/var/log/syslog` is the file that contains the latest logs added.


Function definition of `syslog` and `vsyslog`:
```C
void syslog(int priority, const char *format, ...);
```
```C
void vsyslog(int priority, const char *format, va_list ap);
```

We can observe that there are two arguments for these functions:
* `priority` -  "is formed by ORing together a facility value and a level value". The *facility* argument specifies what type of log it is (LOG\_AUTH, LOG\_CRON) and the *level* represents the importance of the message.
* `format` - this is just a normal format string, it can not end in '\n'.

# Analysing the commit

To understand where the vulnerability lies we will analyse the commit that introduced the unsafe code.

From the source code we can see that `syslog`/`vsyslog` internally call `__vsyslog_internal(pri, fmt, ap, 0)`:
```C
void
 __syslog (int pri, const char *fmt, ...)
 {
  va_list ap;
  
  va_start (ap, fmt);
  __vsyslog_internal (pri, fmt, ap, 0); <-
  va_end (ap);
}
void
 __vsyslog (int pri, const char *fmt, va_list ap)
{ 
  __vsyslog_internal (pri, fmt, ap, 0); <-
}
```

Let's check \_\_vsyslog\_internal:
```C
     //void syslog(int priority, const char *format, ...);
 void __vsyslog_internal (int pri, const char *fmt, va_list ap, unsigned int mode_flags)
 122 {
 123   /* Try to use a static buffer as an optimization.  */
 124   char bufs[1024];                                         <- bufs
 125   char *buf = NULL;
 126   size_t bufsize = 0;
 127   int msgoff;
 128   int saved_errno = errno;
 129 
 130 #define INTERNALLOG LOG_ERR|LOG_CONS|LOG_PERROR|LOG_PID
 131   /* Check for invalid bits. */
 132   if (pri & ~(LOG_PRIMASK | LOG_FACMASK))                                    <- check if arguments are valid
 133     {
 134       syslog (INTERNALLOG, "syslog: unknown facility/priority: %x", pri);
 135       pri &= LOG_PRIMASK | LOG_FACMASK;
 136     }
 137 
 138   /* Prepare for multiple users.  We have to take care: most syscalls we are
 139      using are cancellation points.  */
 140   struct cleanup_arg clarg = { NULL, NULL };
 141   __libc_cleanup_push (cancel_handler, &clarg);
 142   __libc_lock_lock (syslog_lock);
 143 
 144   /* Check priority against setlogmask values. */
 145   if ((LOG_MASK (LOG_PRI (pri)) & LogMask) == 0)
 146     goto out;
 147 
 148   /* Set default facility if none specified. */
 149   if ((pri & LOG_FACMASK) == 0)
 150     pri |= LogFacility;
 151 
 152   pid_t pid = LogStat & LOG_PID ? __getpid () : 0;
 153 
 154   /* "%b %e %H:%M:%S "  */
 155   char timestamp[sizeof "MMM DD hh:mm:ss "];
 156   __time64_t now = time64_now ();                              <- current time
 157   struct tm now_tm;
 158   struct tm *now_tmp = __localtime64_r (&now, &now_tm);        <- now_tm broken down localtime and now_tmp a pointer to it
/*
now_tm = {
    .tm_sec = 45,
    .tm_min = 30, 
    .tm_hour = 14,
    .tm_mday = 16,
    .tm_mon = 5,  
    .tm_year = 125, 
    .tm_wday = 1,  
    .tm_yday = 166,
    .tm_isdst = 0 
};
*/
 159   bool has_ts = now_tmp != NULL;                               <- has\_ts is true if local time is 'fetched' correctly
 160 
 161   /* In the unlikely case of localtime_r failure (tm_year out of int range)
 162      skip the hostname so the message is handled as valid PRI but without
 163      TIMESTAMP or invalid TIMESTAMP (which should force the relay to add the
 164      timestamp itself).  */
 165   if (has_ts)
 166     __strftime_l (timestamp, sizeof timestamp, "%h %e %T ", now_tmp,
 167                   _nl_C_locobj_ptr);
 168 
 169 #define SYSLOG_HEADER(__pri, __timestamp, __msgoff, pid) \
 170   "<%d>%s %n%s%s%.0d%s: ",                               \
 171   __pri, __timestamp, __msgoff,                          \
 172   LogTag == NULL ? __progname : LogTag,                  \
 173   "[" + (pid == 0), pid, "]" + (pid == 0)
/* 
  #define SYSLOG\_HEADER(__pri, __timestamp, __msgoff, pid) "<%d>%s %n%s%s%.0d%s: ", __pri, __timestamp, __msgoff, LogTag == NULL ? __progname : LogTag, "[" + (pid == 0), pid, "]" + (pid == 0)
  important to note here, if LogTag is NULL use __progname  (L52 -crt0 C runtime zero, code that runs before main)
 */
 174 
 175 #define SYSLOG_HEADER_WITHOUT_TS(__pri, __msgoff)        \
 176   "<%d>: %n", __pri, __msgoff
 177 
 178   int l;                                                       <- l is the header length
 179   if (has_ts)
 180     l = __snprintf (bufs, sizeof bufs,
 181                     SYSLOG_HEADER (pri, timestamp, &msgoff, pid));
 182   else
 183     l = __snprintf (bufs, sizeof bufs,
 184                     SYSLOG_HEADER_WITHOUT_TS (pri, &msgoff));
 185   if (0 <= l && l < sizeof bufs)                                <- sizeof bufs is 1024, l how many chars there were written at (L180/L183) in the SYSLOG HEADER
 186     {
 187       va_list apc;
 188       va_copy (apc, ap);
 189 
 190       /* Restore errno for %m format.  */
 191       __set_errno (saved_errno);
 192 
 193       int vl = __vsnprintf_internal (bufs + l, sizeof bufs - l, fmt, apc,  <- vl represents the formated log data
 194                                      mode_flags);
 195       if (0 <= vl && vl < sizeof bufs - l)
 196         buf = bufs;                                           <- buf gets initialised 
 197       bufsize = l + vl;                                       <- bufsize gets value = l (written chars at L180/L183) + vl (L193), this represents the total size of the log message
 198 
 199       va_end (apc);
 200     }
 201 
 202   if (buf == NULL)                                         <- meaning it didn't enter the if from L185 
 203     {
 204       buf = malloc ((bufsize + 1) * sizeof (char));        <- allocate the size + 1 (if bufize is 0 it will allocate the smallest chunk size from the heap available 0x20)
 205       if (buf != NULL)
 206         {
 207           /* Tell the cancellation handler to free this buffer.  */
 208           clarg.buf = buf;
 209 
 210           if (has_ts)
 211             __snprintf (buf, l + 1,                                    <- copy into buf l+1 bytes from the SYSLOG_HEADER (massive overflow)
 212                         SYSLOG_HEADER (pri, timestamp, &msgoff, pid));
 213           else
 214             __snprintf (buf, l + 1,
 215                         SYSLOG_HEADER_WITHOUT_TS (pri, &msgoff));
 216 
 217           va_list apc;
 218           va_copy (apc, ap);
 219           __vsnprintf_internal (buf + l, bufsize - l + 1, fmt, apc,   <- copy log data into buf
 220                                 mode_flags);
 221           va_end (apc);
 222         }
 223       else
 224         {
 225           /* Nothing much to do but emit an error message.  */
 226           bufsize = __snprintf (bufs, sizeof bufs,
 227                                 "out of memory[%d]", __getpid ());
 228           buf = bufs;
 229         }
 230     }
 282 }
 ...
```


#### LogTag

We saw that LogTag should be null, to understand what LogTag does, we also need to analyse how it's initialized.
We can do this by looking in syslog.c and trying to understand how it works.

```C
47 static bool connected;                  /* have done connect */
48 static int LogStat;                     /* status bits, set by openlog() */
49 static const char *LogTag;              /* string to tag the entry with */ <- first appearance
50 static int LogFacility = LOG_USER;      /* default facility code */
...
 169 #define SYSLOG_HEADER(__pri, __timestamp, __msgoff, pid) \
 170   "<%d>%s %n%s%s%.0d%s: ",                               \
 171   __pri, __timestamp, __msgoff,                          \
 172   LogTag == NULL ? __progname : LogTag,                  \ <- second appearance (from code above)
 173   "[" + (pid == 0), pid, "]" + (pid == 0)
...
 291 static void
 292 openlog_internal (const char *ident, int logstat, int logfac)
 293 {
 294   if (ident != NULL)
 295     LogTag = ident;                                        <- third appearance
 296   LogStat = logstat;
 297   if ((logfac & ~LOG_FACMASK) == 0)
 298     LogFacility = logfac;
 299 
 ...
 360 void
 361 closelog (void)
 362 {
 363   /* Protect against multiple users and cancellation.  */
 364   __libc_cleanup_push (cancel_handler, NULL);
 365   __libc_lock_lock (syslog_lock);
 366 
 367   closelog_internal ();
 368   LogTag = NULL;                                   <- fourth appearance
 369   LogType = SOCK_DGRAM; /* this is the default */
 370 
 371   /* Free the lock.  */
 372   __libc_cleanup_pop (1);
 373 }
```

From the code above it looks that LogTag is initialised with an ident only in `openlog\_internal` which is called by `openlog`. The definition of openlog from the manpage is:
```
openlog() opens a connection to the system logger for a program. The string pointed to by ident is prepended to every message, and is typically set to the program name. If ident is NULL, the program name is used. (POSIX.1-2008 does not specify the behavior when ident is NULL.)
```
So to have a null value in LogTag we need to:
a) not call openlog().
b) don't specify an ident.
