import os
import shutil
import re
import subprocess
import time
import signal
import uuid
import pty
import resource
import random
from pathlib import Path
import select

# sudo sysctl -w fs.suid_dumpable=1
os.system("ulimit -c unlimited")

CRASH_DIR = Path("./fuzz_crashes")

MAX_ATTEMPTS = 35000

def wait_for_prompt(fd, prompt=b"Password:"):
    output = b""
    while True:
        r, _, _ = select.select([fd], [], [], 5)
        if fd in r:
            data = os.read(fd, 1024)
            if not data:
                break
            output += data
            if prompt in output:
                return output
        else:
            break
    return output

def sanitize_letters_only(s, max_length=30):
    letters_only = re.sub(r'[^a-zA-Z]', '', s)
    if len(letters_only) > max_length:
        letters_only = letters_only[:max_length] + "..."
    return letters_only

def run_test(prog_name, attempt_num):
    letters = ["A", "B", "P", "I", "F"]
    wild_card = 3000
    j = 0
    while j < 5:
        length = random.randint(1, 10)
        whitelist = ",".join(random.choice(letters) for _ in range(length))
        chance = random.randint(1, 2)
        if chance == 1:
            whitelist += "A," * random.randint(1, wild_card)
        print(f"[Attempt {attempt_num}] Iteration {j}")
        env = os.environ.copy()
        args = [prog_name, "-w"+whitelist]

        pid, fd = pty.fork()
        if pid == 0:
            try:
                os.execve("/usr/bin/su", args, env)
                os.abort()
            except Exception as e:
                print(f"Exec failed: {e}")
                os._exit(1)
        else:
            try:
                output = wait_for_prompt(fd)
                os.write(fd, b"\n")
                output = b""
                timeout_seconds = 6
                last_read_time = time.time()

                while True:
                    rlist, _, _ = select.select([fd], [], [], 0.1)
                    if fd in rlist:
                        try:
                            data = os.read(fd, 1024)
                            if not data:
                                break
                            output += data
                            last_read_time = time.time()
                        except OSError:
                            break
                    else:
                        if time.time() - last_read_time > timeout_seconds:
                            print("[*] Read timeout reached, continuing...")
                            break
                os.close(fd)
                _, status = os.waitpid(pid, 0)
                retcode = os.WEXITSTATUS(status) if os.WIFEXITED(status) else -os.WTERMSIG(status)
                if retcode < 0:
                    error = output.decode(errors="replace")
                    print(f"[!] Crash detected on attempt {attempt_num}: signal {-retcode}")
                    save_crash(whitelist, attempt_num, error, j)
                else:
                    print(f"[+] Attempt {attempt_num} iteration {j} completed successfully with exit code {retcode}")

            except Exception as e:
                print(f"[!] Exception during fuzzing attempt {attempt_num}: {e}")
                save_crash(whitelist, attempt_num)

        j += 1

def save_crash(payload, attempt_num, error="", j=0):
    crash_id = str(uuid.uuid4())[:8]
    err = sanitize_letters_only(error)
    payload_file = CRASH_DIR / f"crash_{attempt_num}_{crash_id}_{err}_{j}.txt"
    gdb_out_file = CRASH_DIR / f"backtrace_{attempt_num}_{crash_id}.txt"

    with payload_file.open("w") as f:
        f.write(payload)

    core_file = find_core(attempt_num, j)
    if core_file:
        print(f"[+] Core found: {core_file}")
        cmd = ["gdb", "-batch", "-ex", "bt", "/usr/bin/su", core_file]
        try:
            with gdb_out_file.open("w") as out:
                subprocess.run(cmd, stdout=out, stderr=subprocess.DEVNULL)
            print(f"[+] Backtrace saved to: {gdb_out_file}")
        except Exception as e:
            print(f"[!] Failed to get backtrace: {e}")
    else:
        print("[!] No core file found")

def find_core(i,j):
    for file in Path(".").glob("core.*"):
        new_name = f"core_{i}_{j}_{file.name}"
        new_path = file.parent / new_name
        shutil.move(str(file), str(new_path))
        return str(new_path)
    return None

def main():
    print("[*] Starting fuzzing...")
    for i in range(1149, MAX_ATTEMPTS + 1):
        try:
            print(f"[*] Attempt {i}")
            run_test("A"*i,i)
        except Exception as e:
            print(f"[!] Unexpected error on attempt {i}: {e}")
            os.waitpid(-1, os.WNOHANG)

if __name__ == "__main__":
    main()

