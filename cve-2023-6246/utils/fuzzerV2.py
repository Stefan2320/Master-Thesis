import os
import sys
import shutil
import re
import subprocess
import time
import signal
import uuid
import pty
import resource
import random
from pathlib import Path
import select


# sudo sysctl -w fs.suid_dumpable=1
os.system("ulimit -c unlimited")

CRASH_DIR = Path("./fuzz_crashes_4")
CRASH_DIR.mkdir(exist_ok=True)

MAX_ATTEMPTS = 35000

def wait_for_prompt(fd, prompt=b"Password:"):
    output = b""
    while True:
        r, _, _ = select.select([fd], [], [], 5)
        if fd in r:
            data = os.read(fd, 1024)
            if not data:
                break
            output += data
            if prompt in output:
                return output
        else:
            break
    return output

def run_test(prog_name, attempt_num):
    length_bounds = {
    'A': (1, 250),
    'P': (1, 250),
    'I': (1, 250),
    'F': (1, 250),
    'B': (1, 250),
    }
    letters = ["A", "B", "P", "I", "F"]
    wild_card = 3000
    j = 0
    while j < 5:
        length = random.randint(1, 50)
        whitelist = ",".join(random.choice(letters) for _ in range(length))
        whitelist += "A," * random.randint(1, wild_card)
        print(f"[Attempt {attempt_num}] Iteration {j}")
        env = os.environ.copy()

        env['LANG'] = 'en_US.UTF-8'
        for var in ['A', 'P', 'I', 'F','B']:
            min_len, max_len = length_bounds[var]
            env[var] = var.lower() * random.randint(min_len, max_len)
        args = [prog_name, "-w"+whitelist]
        pid, fd = pty.fork()
        if pid == 0:
            try:
                os.execve("/usr/bin/su", args, env)
                os.abort()
            except Exception as e:
                print(f"Exec failed: {e}")
                os._exit(1)
        else:
            try:
                output = wait_for_prompt(fd)  
                os.write(fd, b"\n") 
                output = b""
                timeout_seconds = 6
                last_read_time = time.time()

                while True:
                    rlist, _, _ = select.select([fd], [], [], 0.1)
                    if fd in rlist:
                        try:
                            data = os.read(fd, 1024)
                            if not data:
                                break
                            output += data
                            last_read_time = time.time()
                        except OSError:
                            break
                    else:
                        if time.time() - last_read_time > timeout_seconds:
                            print("[*] Read timeout reached, continuing...")
                            break
                os.close(fd)
                _, status = os.waitpid(pid, 0)
                retcode = os.WEXITSTATUS(status) if os.WIFEXITED(status) else -os.WTERMSIG(status)
                if retcode < 0:
                    print(f"[!] Crash detected on attempt {attempt_num}: signal {-retcode}")
                    save_crash(whitelist, attempt_num, j, env)
                else:
                    print(f"[+] Attempt {attempt_num} iteration {j} completed successfully with exit code {retcode}")

            except Exception as e:
                print(f"[!] Exception during fuzzing attempt {attempt_num}: {e}")
                save_crash(whitelist, attempt_num)

        j += 1

def save_crash(payload, attempt_num,  j=0, env={}):
    crash_id = str(uuid.uuid4())[:8]
    payload_file = CRASH_DIR / f"crash_{attempt_num}_{crash_id}_{j}.txt"

    with payload_file.open("w") as f:
        f.write(payload)
        for key, value in env.items():
            f.write(f"{key}={value}\n")

    core_file = find_core(attempt_num, j)
    if core_file:
        print(f"[+] Core found: {core_file}")
    else:
        print("[!] No core file found")

def find_core(i,j):
    for file in Path(".").glob("core.*"):
        new_name = f"core_{i}_{j}_{file.name}"
        new_path = file.parent / new_name
        shutil.move(str(file), str(new_path))
        return str(new_path)
    return None

def main():
    print("[*] Starting fuzzing...")
    for i in range(10000, MAX_ATTEMPTS + 1):
        try:
            print(f"[*] Attempt {i}")
            run_test("A"*i,i)
        except Exception as e:
            print(f"[!] Unexpected error on attempt {i}: {e}")
            os.waitpid(-1, os.WNOHANG)

if __name__ == "__main__":
    main()

